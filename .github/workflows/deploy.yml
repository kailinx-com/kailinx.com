name: Deploy to OCI

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
            type=sha

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to OCI via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.OCI_HOST }}
          username: ${{ secrets.OCI_USERNAME }}
          key: ${{ secrets.OCI_SSH_KEY }}
          script: |
            # Login to GHCR
            echo ${{ secrets.GHCR_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Create app directory structure
            mkdir -p ~/app/nginx/conf.d
            mkdir -p ~/app/certs
            
            # Define Image Name
            export IMAGE_NAME=ghcr.io/${{ github.repository }}:latest
            
            # Pull the new image
            docker pull $IMAGE_NAME
            
            # Write SSL Certificates from Secrets
            echo "${{ secrets.SSL_CERT }}" > ~/app/certs/origin.pem
            echo "${{ secrets.SSL_KEY }}" > ~/app/certs/origin.key
            
            # Write docker-compose.yml
            cat <<EOF > ~/app/docker-compose.yml
            services:
              proxy:
                image: nginx:alpine
                ports:
                  - "80:80"
                  - "443:443"
                volumes:
                  - ./nginx/conf.d:/etc/nginx/conf.d
                  - ./certs:/etc/nginx/certs
                depends_on:
                  - portfolio
                restart: always
                networks:
                  - app-network

              portfolio:
                image: $IMAGE_NAME
                restart: always
                networks:
                  - app-network

            networks:
              app-network:
                driver: bridge
            EOF
            
            # Write Nginx Config
            cat <<EOF > ~/app/nginx/conf.d/default.conf
            # Redirect HTTP to HTTPS
            server {
                listen 80;
                server_name kailinx.com www.kailinx.com;
                return 301 https://\$host\$request_uri;
            }

            # HTTPS Server
            server {
                listen 443 ssl;
                server_name kailinx.com www.kailinx.com;

                ssl_certificate /etc/nginx/certs/origin.pem;
                ssl_certificate_key /etc/nginx/certs/origin.key;
                
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_ciphers HIGH:!aNULL:!MD5;

                location / {
                    proxy_pass http://portfolio:80;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                }
            }
            
            server {
                listen 80 default_server;
                server_name _;
                return 444;
            }
            EOF
            
            # Navigate to app directory
            cd ~/app
            
            # Stop and remove old standalone container if it exists
            docker stop kailinx-site || true
            docker rm kailinx-site || true
            
            # Start Docker Compose
            # Pass the IMAGE_NAME env var to docker compose
            IMAGE_NAME=$IMAGE_NAME docker compose up -d --remove-orphans
            
            # Cleanup unused images
            docker image prune -f
